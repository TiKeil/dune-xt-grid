// This file is part of the dune-xt-grid project:
//   https://github.com/dune-community/dune-xt-grid
// Copyright 2009-2017 dune-xt-grid developers and contributors. All rights reserved.
// License: Dual licensed as BSD 2-Clause License (http://opensource.org/licenses/BSD-2-Clause)
//      or  GPL-2.0+ (http://opensource.org/licenses/gpl-license)
//          with "runtime exception" (http://www.dune-project.org/license.html)
// Authors:
//   Felix Schindler (2017)

#ifndef DUNE_XT_GRID_WALKER_APPLYON_PBH
#define DUNE_XT_GRID_WALKER_APPLYON_PBH
#if HAVE_DUNE_PYBINDXI

#include <sstream>
#include <type_traits>

#include <dune/pybindxi/pybind11.h>
#include <dune/pybindxi/operators.h>

#include <dune/xt/grid/intersection.hh>
#include <dune/xt/grid/gridprovider/provider.hh>
#include <dune/xt/grid/boundaryinfo/interfaces.hh>

#include "apply-on.hh"

namespace Dune {
namespace XT {
namespace Grid {
namespace internal {


template <class C, class BI, bool with_bi = false>
struct bind_WhichIntersection
{
  pybind11::class_<C> operator()(pybind11::module& m, const std::string& class_id, const std::string& method_id)
  {
    namespace py = pybind11;
    using namespace pybind11::literals;

    py::class_<C, ApplyOn::WhichIntersection<typename C::GridViewType>> c(m, class_id.c_str(), class_id.c_str());
    c.def(py::init<>());

    m.def(method_id.c_str(), [](const BI& /*boundary_info*/) { return C(); }, "boundary_info"_a);

    return c;
  }
}; // struct bind_WhichIntersection

template <class C, class BI>
struct bind_WhichIntersection<C, BI, true>
{
  pybind11::class_<C> operator()(pybind11::module& m, const std::string& class_id, const std::string& method_id)
  {
    namespace py = pybind11;
    using namespace pybind11::literals;

    py::class_<C, ApplyOn::WhichIntersection<typename C::GridViewType>> c(m, class_id.c_str(), class_id.c_str());
    c.def(py::init<const BI&>());

    m.def(method_id.c_str(), [](const BI& boundary_info) { return C(boundary_info); }, "boundary_info"_a);

    return c;
  }
}; // struct bind_WhichIntersection<..., true>


} // namespace internal


template <class GV>
void addbind_WhichIntersection(pybind11::module& m, const std::string& grid_id, const std::string& layer)
{
  namespace py = pybind11;
  using namespace pybind11::literals;

  py::class_<ApplyOn::WhichIntersection<GV>>(m,
                                             std::string("ApplyOnWhichIntersection__" + grid_id + "_" + layer).c_str(),
                                             std::string("ApplyOnWhichIntersection__" + grid_id + "_" + layer).c_str());

  internal::bind_WhichIntersection<ApplyOn::AllIntersections<GV>,
                                   BoundaryInfo<typename Intersection<GV>::type>,
                                   false>()(
      m, "ApplyOnAllIntersections__" + grid_id + "_" + layer, "make_apply_on_all_intersections__" + layer);

  internal::bind_WhichIntersection<ApplyOn::InnerIntersections<GV>,
                                   BoundaryInfo<typename Intersection<GV>::type>,
                                   false>()(
      m, "ApplyOnInnerIntersections__" + grid_id + "_" + layer, "make_apply_on_inner_intersections__" + layer);

  internal::bind_WhichIntersection<ApplyOn::InnerIntersectionsPrimally<GV>,
                                   BoundaryInfo<typename Intersection<GV>::type>,
                                   false>()(m,
                                            "ApplyOnInnerIntersectionsPrimally__" + grid_id + "_" + layer,
                                            "make_apply_on_inner_intersections_primally__" + layer);

  internal::bind_WhichIntersection<ApplyOn::BoundaryIntersections<GV>,
                                   BoundaryInfo<typename Intersection<GV>::type>,
                                   false>()(
      m, "ApplyOnBoundaryIntersections__" + grid_id + "_" + layer, "make_apply_on_boundary_intersections__" + layer);

  internal::bind_WhichIntersection<ApplyOn::NonPeriodicBoundaryIntersections<GV>,
                                   BoundaryInfo<typename Intersection<GV>::type>,
                                   false>()(m,
                                            "ApplyOnNonPeriodicBoundaryIntersections__" + grid_id + "_" + layer,
                                            "make_apply_on_nonperiodic_boundary_intersections__" + layer);

  internal::bind_WhichIntersection<ApplyOn::PeriodicIntersections<GV>,
                                   BoundaryInfo<typename Intersection<GV>::type>,
                                   false>()(
      m, "ApplyOnPeriodicIntersections__" + grid_id + "_" + layer, "make_apply_on_periodic_intersections__" + layer);

  internal::bind_WhichIntersection<ApplyOn::PeriodicIntersectionsPrimally<GV>,
                                   BoundaryInfo<typename Intersection<GV>::type>,
                                   false>()(m,
                                            "ApplyOnPeriodicIntersectionsPrimally__" + grid_id + "_" + layer,
                                            "make_apply_on_periodic_intersections_primally__" + layer);

  internal::bind_WhichIntersection<ApplyOn::DirichletIntersections<GV>,
                                   BoundaryInfo<typename Intersection<GV>::type>,
                                   true>()(
      m, "ApplyOnDirichletIntersections__" + grid_id + "_" + layer, "make_apply_on_dirichlet_intersections__" + layer);

  internal::bind_WhichIntersection<ApplyOn::NeumannIntersections<GV>,
                                   BoundaryInfo<typename Intersection<GV>::type>,
                                   true>()(
      m, "ApplyOnNeumannIntersections__" + grid_id + "_" + layer, "make_apply_on_neumann_intersections__" + layer);
} // ... addbind_WhichIntersection(...)


} // namespace Grid
} // namespace XT
} // namespace Dune

#endif // HAVE_DUNE_PYBINDXI
#endif // DUNE_XT_GRID_WALKER_APPLYON_PBH
